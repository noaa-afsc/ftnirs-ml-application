---
title: Test page
---

## Getting started

### Formatting data

First, you will need to identify a suitable dataset. The technique specifically accepts both spectroscopy data along with other per-otolith biological or spatiotemporal contextual data. The codebase and app use a fairy primitive string matching protocol, and they both make assumptions about what certain columns do based on naming, so remember:

**What you name columns matters!**

All of the naming conventions are defined at the codebase level, within the file ["constants"](https://github.com/noaa-afsc/ftnirs-ml-codebase/blob/main/ftnirsml/constants.py). Here are some examples of a few of them at the time of writing:

* IDNAME = "id"
* RESPONSENAME = "age"
* WN_STRING_NAME = 'wn**'
* SPLITNAME = "split"

This means that the codebase and application will give columns with these names special treatment, and so when preparing data you will need to be very aware when you need to name your dataset with on of these columns. Here are their definitions:

* id: a unique identifier that should be globally unique to the specific otolith. Keeping the id specific to the identity of the otolith is important, as when many datasets are being used for training there are filters within the app to ensure that incidental duplicate values that lead to dataset contamination and comprimised results are not present (***note to self: check: are there?***) The contents are not as important, this could be a path to an image, an integer key, a hash, etc.

* age: this is the response variable, and while it is not necessary to include in every dataset (such as when this is not available and should be predicted with inference in the app), it is needed for model training or fine-tuning. The app will be flexible if the age column is provided but ages are only available for certain rows- for these datasets, mark missing ages as NA.  

* wn\*\*: this is the syntax that wav numbers should correspond to. The app will assume any column with characters containing 'wn' (***note to self, this is a good back end improvement, should just match to start of string***) is a wav number column. The numbers should directly follow the 'wn' prefix, so a value 8000 would be specified as "wn8000". Decimal values are ok, ie wn8000.0023. 

* split: OPTIONAL: this is defined if you would like to define custom training splits during training. If you do want to define training splits, you must define this columns with the exact categories "training","validation","test" (you may leave out one or two of these as desired). You can also define this column, and within the app still specify app generated splits as desired.

In addition to these specific values, there is also a registry of 'standard variables', which help combine like data between different groups and also contain information about the type of data which help for how the application treats these data types. Here is an example of how these are defined: 

STANDARD_COLUMN_NAMES = {IDNAME:{'data_type':'unq_text'},
        SPLITNAME:{'data_type':'int'},
        'catch_year' : {'data_type':'int'},
        'catch_month': {'data_type': 'int'},
        'catch_day': {'data_type': 'int'},
        'sex' : {'data_type':'categorical'},
        RESPONSENAME : {'data_type':'numeric'},
        'latitude' : {'data_type':'numeric'},
        'longitude' : {'data_type':'numeric'},
        'region': {'data_type': 'categorical'},
        'fish_length': {'data_type': 'numeric'},
        'fish_weight': {'data_type': 'numeric'},
        'otolith_weight': {'data_type': 'numeric'},
        'gear_depth': {'data_type': 'numeric'},
        'gear_temp': {'data_type': 'numeric'}
        }

In the above, declaring categorical variables will allow for instance the application to automatically apply one-hot encoding to these variables. (***note to self, this is a good back end improvement, define UNITS ***)


### Formatting models

* See examples of use of the ML codebase, including the case where you convert an existing model into the compatible model format. 
